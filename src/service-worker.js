
/**
 * StudyBee Service Worker
 * Provides offline functionality for the StudyBee application
 */
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { BackgroundSyncPlugin } from 'workbox-background-sync';
import { clientsClaim } from 'workbox-core';

// Claim client immediately to control the page instantly
self.skipWaiting();
clientsClaim();

// Precache all assets generated by your build process
// This uses the __WB_MANIFEST array of file URLs generated by the Workbox CLI
precacheAndRoute(self.__WB_MANIFEST || []);

// Handle navigation requests with a Network First strategy
const navigationHandler = createHandlerBoundToURL('/index.html');
const navigationRoute = new NavigationRoute(navigationHandler, {
  allowlist: [new RegExp('^/$|^/[^.]*$')],
  denylist: [new RegExp('\\.(js|css|png|jpg|jpeg|gif|svg|ico)$')],
});

registerRoute(navigationRoute);

// Cache JavaScript and CSS using StaleWhileRevalidate strategy
registerRoute(
  ({ request }) => request.destination === 'script' || request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: 'js-css-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 1 week
      }),
    ],
  })
);

// Cache images with a Cache First strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'image-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Cache fonts with a Cache First strategy
registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: 'font-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 60 * 24 * 60 * 60, // 60 days
      }),
    ],
  })
);

// Network First for all Supabase API calls, with an offline fallback
registerRoute(
  ({ url }) => url.href.includes('supabase'),
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 24 * 60 * 60, // 1 day
      }),
    ],
  })
);

// Enhanced background sync for offline operations
const studyBeeBackgroundSync = new BackgroundSyncPlugin('study-bee-offline-operations', {
  maxRetentionTime: 24 * 60, // Retry for max 24 Hours (specified in minutes)
  onSync: async ({ queue }) => {
    // Process the queue
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        // Get the stored request
        const request = entry.request.clone();
        const response = await fetch(request);
        
        // Check if the request was successful
        if (response && response.status >= 200 && response.status < 300) {
          // If successful, continue to the next request
          continue;
        } else {
          // If unsuccessful, throw so it's added back to the queue
          throw new Error(`Request failed with status ${response.status}`);
        }
      } catch (error) {
        // Add the request back to the queue if it fails
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  }
});

// Register route for background sync of data
registerRoute(
  ({ url }) => {
    return (
      url.pathname.includes('/flashcards') || 
      url.pathname.includes('/quiz') || 
      url.pathname.includes('/study-timer') ||
      url.pathname.includes('/notes')
    );
  },
  new NetworkFirst({
    cacheName: 'api-requests',
    plugins: [studyBeeBackgroundSync],
  }),
  'POST'
);

// Handle background sync events
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-data') {
    event.waitUntil(syncData());
  }
});

// Sync data from indexedDB
async function syncData() {
  // Notify the client to perform sync
  const clients = await self.clients.matchAll({ type: 'window' });
  for (const client of clients) {
    client.postMessage({ type: 'SYNC_DATA' });
  }
}

// Listen for messages from the main thread
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
  
  if (event.data && event.data.type === 'CACHE_FLASHCARDS') {
    cacheFlashcards(event.data.flashcards);
  }
  
  if (event.data && event.data.type === 'CACHE_QUIZ_DATA') {
    cacheQuizData(event.data.quizData);
  }
});

/**
 * Caches flashcard data for offline use
 * @param {Array} flashcards - Array of flashcard objects to cache
 */
async function cacheFlashcards(flashcards) {
  const cache = await caches.open('flashcards-cache');
  await cache.put(
    '/flashcards-data',
    new Response(JSON.stringify(flashcards), {
      headers: { 'Content-Type': 'application/json' },
    })
  );
}

/**
 * Caches quiz data for offline use
 * @param {Object} quizData - Quiz data to cache
 */
async function cacheQuizData(quizData) {
  const cache = await caches.open('quiz-cache');
  await cache.put(
    '/quiz-data',
    new Response(JSON.stringify(quizData), {
      headers: { 'Content-Type': 'application/json' },
    })
  );
}

/**
 * Prefetch common application routes for offline use
 * This improves the offline experience by ensuring key pages are available
 */
function prefetchRoutes() {
  const routesToPrefetch = [
    '/',
    '/dashboard',
    '/flashcards',
    '/flashcard-review',
    '/quiz',
    '/study-timer',
    '/profile'
  ];
  
  const cache = caches.open('offline-routes');
  
  return Promise.all(
    routesToPrefetch.map(route => {
      // Create a safe request to avoid caching issues
      const request = new Request(route, { cache: 'no-cache' });
      return fetch(request)
        .then(response => {
          if (response.ok) {
            return cache.then(c => c.put(route, response));
          }
        })
        .catch(err => console.warn(`Failed to prefetch ${route}:`, err));
    })
  );
}

// Prefetch routes on install
self.addEventListener('install', event => {
  event.waitUntil(prefetchRoutes());
});
